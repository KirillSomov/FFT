
#include "SPI.h"


// деинициализация контроллера SSP
void SPI2_Reset(void)
{	
  MDR_SSP2->CR0   = 0;
  MDR_SSP2->CR1   = 0;
  MDR_SSP2->CPSR  = 0;
  MDR_SSP2->IMSC  = 0;
  MDR_SSP2->DMACR = 0;
}


// конфигурация порта для работы интерфейса SPI (SSP2)
void SPI2_PortCfg(void)
{
	// PORTD
  // конфигурация линий PD2 (RXD), PD3 (FSS), PD5 (CLK), PD6 (TXD)
  MDR_PORTD->OE     &= ~(1 << 2);                                       				// PD2 (RXD) - вход
  MDR_PORTD->OE     |=  ((1 << 3)  | (1 << 5)  | (1 << 6));               			// PD3 (FSS), PD5 (CLK), PD6 (TXD) - выход
  MDR_PORTD->ANALOG |=  ((1 << 2)  | (1 << 3)  | (1 << 5)  | (1 << 6));   			// режим работы - цифровой
  MDR_PORTD->FUNC   &= ~((3 << 2*2)  | (3 << 3*2)  | (3 << 5*2)  | (3 << 6*2)); // сброс регистра FUNC
  MDR_PORTD->FUNC   |=  ((2 << 2*2)  | (0 << 3*2)  | (2 << 5*2)  | (2 << 6*2)); // уст регистра FUNC - PD2, PD5, PD6 альтернативная функция; PD3 ввод/вывод
  MDR_PORTD->PWR    |=  ((3 << 2*2)  | (3 << 3*2)  | (3 << 5*2)  | (3 << 6*2)); // максимально быстрый фронт
}


// инициализация нитерфейса SPI2
void SPI2_Init(void)
{
  // конфигурация порта
  SPI2_PortCfg();
	
	// разрешение тактовой частоты SSP2
	MDR_RST_CLK->SSP_CLOCK |= ((0 << 8)			// делитель 1: SSP2_CLK = HCLK = 80 MHz
														|(1 << 25));	// вкл тактовой частоты на SSP2
	
	// деинициализация контроллера SSP2
	SPI2_Reset();
	
	// конфигурация контроллера SSP
	MDR_SSP2->CR0 = ((7 << 0)			// DSS: размер слова - 8 бит
									|(0 << 4)			// FRF: протокол SPI Motorola
									|(0 << 6)			// SPO: 
									|(0 << 7)			// SPH: 
									|(0 << 8));		// SCR: SCR = 0, V = 80 MHz / (2 * (1 + 0)) = 40 MHz
	
	MDR_SSP2->CR1 = ((0 << 0)			// LBM: нормальный режим работы
									|(1 << 1)			// SSE: работа разрешена
									|(0 << 2));		// MS: ведущий модуль
	
	// задание делителя тактовой частоты
	MDR_SSP2->CPSR = (2 << 0);		// CPSDVSR: коэф. = 2; V = 80 MHz / (2 * (1 + 0)) = 40 MHz
}

	
// передача данных по интерфейсу SPI
void SPI2_sendData(uint16_t data)
{	
	// передача данных
	MDR_SSP2->DR = data;
	
	// ожидание завершения передачи
	while((MDR_SSP2->SR & (1 << 4)) != 0)	{;}		// флаг освобождения модуля SSP2
	while((MDR_SSP2->SR & (1 << 0)) == 0)	{;}		// флаг освобождения буфера передатчика
}	
